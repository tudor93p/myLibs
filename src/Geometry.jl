module Geometry
#############################################################################

import ConcaveHull


import ..Utils






#===========================================================================#
#
# Decides whether a point is in a polygon
#
#---------------------------------------------------------------------------#


function is_left(P0, P1, P2)::Real

	(P1[1] - P0[1]) * (P2[2] - P0[2]) - (P2[1] - P0[1]) * (P1[2] - P0[2])

end 

function PointInPolygon_wn(P::Utils.List, V::AbstractMatrix; 
													 dim, prepare_vertices=true, kwargs...)::Bool

  wn = 0   # the winding number counter

  						# repeat the first vertex at the end

	if prepare_vertices

		V = prepare_polygon_vertices(V; dim=dim, kwargs...)

	end 

	v(i) = selectdim(V, dim, i)

	v(i,j) = v(i)[j]



  # loop through all edges of the polygon

	for i in 1:size(V, dim)-1  # edge from v(i) to v(i+1) 

		if v(i,2) <= P[2] # start y <= P[1]

			if v(i+1,2)>P[2] && is_left(v(i), v(i+1),P)>0 
									# an upward crossing & P left of edge
			
				wn += 1           # have a valid up intersect

			end 

			 
		else # start y > P[2] (no test needed)
			 
			if v(i+1,2)<=P[2] && is_left(v(i), v(i+1), P)<0

						
						# a downward crossing &  P right of edge

				wn -= 1           # have a valid down intersect


			end

		end 

	end 

  return wn != 0


end 




#===========================================================================#
#
#
#
#---------------------------------------------------------------------------#


function Order_PolygonVertices(V::AbstractMatrix; dim)::AbstractMatrix

	C = sum(V, dims=dim)[:]/size(V,dim) # center of the polygon

	return sortslices(V, dims=dim, by = R->atan(R[2]-C[2], R[1]-C[1]))

end 



function prepare_polygon_vertices(V::AbstractMatrix; 
																	order_vertices=false, dim)::Matrix

	if order_vertices

		return prepare_polygon_vertices(
								Order_PolygonVertices(V, dim=dim),
								order_vertices=false, dim=dim)

	end 

	return cat(selectdim(V, [2,1][dim], 1:2),
					selectdim(selectdim(V, [2,1][dim], 1:2), dim, 1:1),
					dims=dim)

end 

function PointInPolygon_wn(V::AbstractMatrix; kwargs...)::Function

	V = prepare_polygon_vertices(V; kwargs...) 
															 
	return P -> PointInPolygon_wn(P, V; kwargs..., prepare_vertices=false)

end 








#===========================================================================#
#
# Generate vertices of a d-dimensional body based on d vectors
# (1D: segmemt, 3D: parallelipiped, 2D:parallelogram)
#
#---------------------------------------------------------------------------#


function rhomboidVertices_fromDVectors(v::AbstractMatrix; dim)::Matrix

	Utils.CombsOfVecs10(v, 1, 0; dim=dim)

end





#===========================================================================#
#
#
#
#---------------------------------------------------------------------------#



function concave_hull(points::AbstractVector{AbstractVector{<:Real}}; outdim=2)
	
	ch = ConcaveHull.concave_hull(points)


	s = Utils.Array_from_ListIndsVals(
							[outdim,[2,1][outdim]],
							[length(ch.vertices), length(ch.vertices[1])]
							)

	out = similar(ch, Tuple(s))

	
	for (i,v) in enumerate(ch.vertices)

		setindex!(selectdim(out, dim, i), v, :)

	end 


	return out

end 



function concave_hull(points::AbstractMatrix{<:Real}; dim=2, kwargs...)

	concave_hull(collect(eachslice(points, dims=dim)); kwargs...)

end

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#############################################################################
end
